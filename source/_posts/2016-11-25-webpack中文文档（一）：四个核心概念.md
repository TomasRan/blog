title: webpack中文文档（一）：四个核心概念
categories:
  - Translation
tags:
  - webpack
  - webpack中文文档
abbrlink: nuYBhl8kXuC-kcxZKGpMxg
date: 2016-11-25 14:41:41
---
原文链接：https://webpack.js.org/concepts/

## 介绍<span id='introduce'></span>
webpack是为了现代Javascript应用而诞生的一个模块打包器。它拥有[惊人的可配置性](https://webpack.js.org/configuration/)，不过，在使用之前我们觉得你必须理解四个核心的概念。

作为webpack学习之旅的一部分，我们撰写这篇文档旨在给大家展示这些概念的高度概览，不过我们也会提供和概念相关的特定用例的链接。

### 入口
webpack会根据你的应用的依赖关系创建一张图。这张图的起点被视为入口。入口告诉webpack从哪里开始，以及按照依赖关系图如何去打包。你可以将你的应用的入口看做是上下文根节点或者访问你的应用的第一个文件。

在webpack中，我们通过在 [webpack配置对象](https://webpack.js.org/configuration/) 中使用 `entry` 属性定义入口。

下面是一个最简单的例子：

webpack.config.js

```javascript
module.exports = {
	entry: './path/to/my/entry/file.js' 
};
```

根据你的应用的需求，可以有多种方法去声明入口。

[了解更多！](#entry)

### 输出
当你打包完了所有的资源文件，我们仍然需要告诉webpack哪里去放置我们的应用。webpack的 `ouput` 属性描述了webpack如何去处理打包后的代码。

webpack.config.js

```javascript
module.exports = {
	entry: './path/to/my/entry/file.js',
	output: {
		path: path.resolve(__dirname, 'dist'),
		filename: 'my-first-webpack.bundle.js'
	}
};
```

上面的例子，通过我们定义的 `output.filename` 和 `ouput.path` 属性去命名我们的包以及确定我们想要将它放置的位置。

`ouput` 属性拥有很多的配置功能，但是我们还是应该花一些时间去理解 `output` 属性更为通用的配置用例。

[了解更多！](#output)

### 加载器
目标是使得你项目中的所有资源文件成为webpack的关注点，而浏览器无需关心（这并不意味着所有的资源文件都需要一起打包）。webpack 将 [每一个文件（.css，.html，scss，.jpg，etc）视为一个模块](#modules)。然而，webpack
__只能理解Javascript代码__。

__当将资源文件添加到你的依赖图中时，webpack中的加载器会将涉及的所有文件统统转化成为模块。__

从高层次上来讲，你的webpack配置主要有两个目的：

1. 通过特定的加载器识别需要进行转换的文件。（`test` 属性）
2. 将文件进行装换以便于它能够被添加到你的依赖图中（最终添加到你的包中）。（`use` 属性）

webpack.config.js

```javascript
const config = {
	entry: './path/to/my/entry/file.js',
	output: {
		path: path.resolve(__dirname, 'dist'),
		filename: 'my-first-webpack.bundle.js'
	},
	module: {
		rules: [
			{test: /\.(js|jsx)$/, use: 'babel-loader'}
		]
	}
};
```

上面的配置中我们定义了使用加载器的规则，设置了它的两个必须属性：`test` 和 `use` 。它告诉webpack编译器下面的事情：

>  “webpack编译器，当你在分析 `require()/import` 声明中的路径时，遇到了 '.js' 或者 ‘.jsx’文件，则在将它添加到打包结果之前，使用 `babel-loader` 去将它转换为模块。”

当在你的webpack配置中定义规则时，需要切记你应该在 `module.rules` 下面进行定义，而不是 `rules`。不过如果你采用了错误的方式webpack也会发出提醒。

关于加载器还有很多我们没有谈及的特定属性可以进行定义。

[了解更多！](#loader)

### 插件
加载器是基于每个文件执行转换，而`plugins` 一般用来（但不局限于）在你的已经打包好的模块的“编译”或是“分块”	期间执行一些操作和自定义的功能（[或者更多](#plugins)）。webpakc的插件系统[十分强大并且可定制](https://webpack.js.org/api/plugins/)。

为了使用一个插件，你只需要 `require（）` 它并且将它添加到 `plugins` 数组。大多数的插件都是可以通过参数进行定制的。因为你可以根据不同目的在同一配置文件中多次使用同一个插件，所以你需要使用 `new` 去初始化该插件的实例。

webpack.config.js

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
const webpack = require('webpack'); //to access built-in plugins

const config = {
	entry: './path/to/my/entry/file.js',
	output: {
		filename: 'my-first-webpack.bundle.js',
		path: './dist'
	},
	module: {
		rules: [
			{test: /\.(js|jsx)$/, use: 'babel-loader'}
		]
	},
	plugins: [
		new webpack.optimize.UglifyJsPlugin(),
		new HtmlWebpackPlugin({template: './src/index.html'})
	]
};

module.exports = config;
```

webpack提供了很多插入即用的插件！可以查看我们的 [插件列表](https://webpack.js.org/plugins/) 以获取更多信息。

在你的webpack配置中使用插件相当轻松，然而有很多的用例更值得进一步讨论。

[了解更多！](#plugins)

## 入口<span id='entry'><span>
正如我们在 [介绍](#introduce) 中提及的，在你的webpack配置文件中有多种方式去定义 `entry` 属性。我们将要介绍配置 `entry` 属性的方法，并且解释为什么它于你可能有用。

### 单入口 [简写] 语法
用法：`entry: String|Array<String>`

webpack.config.js

```javascript
const config = {
	entry: './path/to/my/entry/file.js'
};

module.exports = config;
```

以上针对 `entry` 属性的单入口语法其实是下面的简写形式：

```javascript
const config = {
	entry: {
		main: './path/to/my/entry/file.js'
	}
};
```

> 当你传递一个数组给 `entry` 属性会发生什么？传递一个文件路径的数组给 `entry` 属性会建立一个所谓的“多主入口（multi-main entry）”。当你想要将多个独立的文件以及它们的依赖关系图一起注入到某个“分块（chunk)）”中的时候，这会非常有用。

当你正在为仅拥有一个入口的应用或者工具（例如：一个库）寻找快速构建webpack应用的方法时，单入口语法将是很不错的选择。然而，当你需要为配置文件进行扩展时，这种语法的灵活性不足。

### 对象语法
用法：`entry: {[entryChunkName: String]: String|Array<String>}`

webpack.config.js

```javascript
const config = {
	entry: {
		app: './src/app.js',
		vendors: './src/vendors.js'
	}
};
```

这种语法较为冗长。然而，在你的应用中使用这种方式定义单个/多个入口最具有可伸缩性。

> “可伸缩的webpack配置（scalable webpack configurations）”指的是可以被复用以及能够由其它部分配置组合生成的配置。这是一个很受欢迎的技术，用来将环境，构建目标和运行环境分离。之后在用特定的工具将它们进行合并，例如 [webpack-merge](https://github.com/survivejs/webpack-merge)。

### 场景
下面是入口配置的一个列表以及在现实中的用例。

#### 分离应用程序和第三方库入口
webpack.config.js

```javascript
const config = {
	entry: {
		app: './src/app.js',
		vendors: './src/vendors.js'
	}
};
```

它做了什么？从表面上来看，它告诉webpack分别从 `app.js` 和 `vendors.js` 这两个文件开始建立依赖关系图。这两张图完全是分开的，彼此独立（在每个bundle里都有一个webpack引导程序）。在只拥有一个入口的单页应用中通常都是这种情况（除了第三方库之外）。

为什么？这种配置方式允许你利用 `CommonsChunkPlugin` 以及从你的应用程序bundle中提取第三方库的参考文献到第三方库的bundle中，并以 `__webpack_require__()` 调用代之。如果在你的应用程序bundle中没有第三方库的代码，你可以在webpack中实现一个公共模式，即所谓的 [长期的第三方库缓存（long-term vendor-caching）](https://webpack.js.org/guides/caching/)。

#### 多页应用
webpack.config.js

```javascript
const config = {
	entry: {
		pageOne: './src/pageOne/index.js',
		pageTwo: './src/pageTwo/index.js',
		pageThree: './src/pageThree/index.js'
	}
};
```

它做了什么？我们正在告诉webpack我们想要三个独立的依赖关系图（就像上面例子的配置）。

为什么？在多页应用中，服务器会取得新的HTML文档给你。页面重新加载新的文档，资源文件也会被重新下载。然而，这给了我们一个特别的机会去做很多事情：

*  使用 `CommonsChunkPlugin` 在页面之间创建它们所共享的应用程序代码的bundle文件。对于在不同的入口之间复用大量代码和模块的多页应用程序，当入口数量增加的时候，会从此技术上获取很大的益处。

> 首要规则：一个HTML文件只使用一个入口。

## 输出<span id='output'></span>
## 加载器<span id='loader'></span>
## 插件<span id='plugins'></span>
## 配置<span id='configurations'></span>
## 模块<span id='modules'></span>
## 模块分解<span id='modules-resolution'></span>
## 依赖图<span id='dependency-graph'></span>
## 目标<span id='target'></span>
## 热模块替换<span id='hot-module'></span>
